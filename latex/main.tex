% !TeX encoding = UTF-8
% !TeX program = pdflatex
% !TeX spellcheck = it_IT

% \documentclass[a4paper, 11pt]{article}
\documentclass[Lau,binding=0.6cm]{sapthesis}

\usepackage{microtype}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenx}
\usepackage[hidelinks]{hyperref}
\usepackage{amssymb}
\usepackage{hyperref}

\usepackage{titlesec}
\titleformat{\chapter}[hang]{\Huge\bf}{\thechapter{. }}{0pt}{\Huge\bf}

\hypersetup{pdftitle={tesi},pdfauthor={Andrei Laurentiu Lepadat}}

\title{Using Sensor and Process Noise Fingerprint to Detect Cyber Attacks in CPS}
\author{Andrei Laurentiu Lepadat}
\IDnumber{1677093}
\course{Informatica}
\courseorganizer{Facoltà di Ingegneria dell'Informazione, Informatica e Statistica}
\AcademicYear{2020/2021}
\copyyear{2021}
\advisor{Prof. Enrico Tronci}
\authoremail{lepadat.1677093@studenti.uniroma1.it}

\versiondate{\today}

\begin{document}

\frontmatter

\maketitle

\dedication{Decidere se inserire. Ne vale la pena?}

% ----------------------------------------------------------------------------------------

\tableofcontents

\chapter{Sommario} 
% Massimo una pagina da scrivere alla fine

% ----------------------------------------------------------------------------------------   

\mainmatter

\chapter{Introduzione}
% Scrivere alla fine 

\section{Contesto}
% Short description of context,  for example:
% Tutti gli essere vivneti per sopravviver hanno bisogno di alimentarsi.
% Gli uomini sono essere viventi, e quindi hanno bisogno di alimentarsi.

\section{Motivazioni}
% Motivation for what we want to do. esempio:
% Purtroppo la mancanza di una alimentazione adeguata è uno dei problemi più importanti nei paesi sottosviluppati

\section{Contributi}
% Describe here your contributions, namely the missing items identified in the motivations. esempio:
% Questo lavoro propone un metodo per generare cibo per tutti gli abitanti dei paesi sottosviluppati ...

\section{Stato dell'arte}
% Describe here the state of the art (e.g., algorithms and tools  available).
% For each paper/tool explain what you do that is not already available (killing).

\section{Struttura}
% Give an outline of the thesis structure (one sentence per section)


% ----------------------------------------------------------------------------------------

\chapter{Background}\label{chap:1}
% Put in this section all the background knowledge needed to understand what you did.
% Parlare di dati di sensori, serie temporali estratti dai sensori, rmse, rumore intrinseco sensori --> residual
% machine learning model e decision 

Ogni sistema cyber-fisico che si rispetti è dotato di almeno un sensore che ha il compito di misurare una determinata ``qualità'' fisica di interesse per il sistema stesso. 
I dati che vengono rilevati dai sensori spesso vengono memorizzati localmente e/o in modo remoto e possono essere impiegati,
come nel lavoro qui presentato, per fini paralleli o trasversali a quelli per cui sono stati installati.
Una sequenza di dati estratti da sensori ordinata temporalmente viene chiamata \textit{serie temporale} (\textit{time-series} in inglese).

Comunemente i sensori sono imperfetti per costruzione e trasportano intrinsecamente un'incertezza (\textit{process noise}) che influenza le misurazioni da essi compiute.
Sia 
\begin{equation}
\bar{y}_{k} = y_{k} + \delta_{k}\label{eq:1}
\end{equation}
il valore misurato da un determinato sensore nell'istante di tempo \textit{k}, composto da $y_k$, il valore effettivo in quell'istante della grandezza misurata, più $\delta_k$, il rumore aggiunto.

In un determinato istante di tempo, il valore di ogni sensore del sistema costituisce lo \textit{stato} del sistema.
La sfida di estrarre il fingerprint dai sensori è data dal fatto che questi stati sono dinamici. 
Prendendo in considerazione, per esempio, un termometro, se la temperatura dell'ambiente che misura rimane costante nel tempo è facile estrarre il fingerprint del rumore e costruirne il profilo, 
ma in processi reali non è così semplice, gli stati cambiano continuamente, per esempio l'aumento di velocità di una macchina per via della pressione sul pedale dell'acceleratore.
\`E importante catturare queste variazioni affinch\'e le misurazioni dinamiche dei sensori possano essere stimate.
In [1] questo problema viene affrontato definendo un modello analitico del sistema interessato, rappresentato tramite il modello \textit{State-Space}. 
Vengono implementate le tecniche definite in [2], definendo cos\`i il modello lineare tempo inviariante (LTI) del sistema, rappresentato dal sistema di equazioni
\begin{equation}\label{eq:4}
    \begin{cases}
        x_{k+1} = Ax_k + Bu_k + \vartheta_k, \\
        y_k = Cx_k + \eta_k:
    \end{cases}
\end{equation}
in cui $x_k \in \mathbb{R}^n$ rappresenta lo stato del sistema, $u_k \in \mathbb{R}^p$ l'input di controllo e
$\vartheta_k$ il rumore al tempo $k$.
$y_k \in \mathbb{R}_m$ e $\eta_k \in \mathbb{R}_m$ rappresentano, rispettivamente, la misurazione e il rumore del sensore al tempo $k$.
$A$, $B$, $C$ sono le matrici dello spazio di stato di dimensioni adeguate che rappresentato la dinamica del sistema.

Definito il precedente sistema, ci sono molti punti che un attaccante mal intenzionato potrebbe bersagliare.
Nel lavoro presentato, cos\`i come in [1], vengono presi in considerazione \textit{spoofing attack} ai sensori che potrebbero essere portati a termine tramite uno schema \textit{Man-in-The-Middle}.
L'equazione lineare che rappresenta questa tipologia di attacchi \`e data da
\begin{equation}
\bar{y}_{k} = y_{k} + \delta_{k} = Cx_k + \eta_k + \delta_k,\footnote{Notare l'ugualianza con l'equazione \ref{eq:1}: un attacco \`e considerato come un'introduzione di rumore nella misurazione fatta da un sensore.}
\end{equation}
in cui $\delta_k \in \mathbb{R}_m$ rappresenta un attacco ai sensori.

In [1], dato l'output $\bar{y}_k$, viene adoperato il \textit{filtro di Kalman} per stimare lo stato del sistema e il vettore dei \textit{residui}, definito, in questo contesto, come la differenza tra la reale misurazine effettuata dal sensore
e la stima della misurazione calcolata dal filtro nell'istante $k$:
\begin{equation}
    r_k := \bar{y}_k - \hat{y}_k,
\end{equation}
dove $\hat{y}_k$ \`e l'output del filtro di Kalman.

Detto ci\`o, per quantificare la bont\`a del modello del sistema, viene utilizzato l'\textit{Errore Quadratico Medio (RMSE)}, definito come
\begin{equation}
    RMSE = \sqrt{\frac{\sum_{i=1}^n (y_i - \hat{y}_i)}{n}}.
\end{equation}
Questa metrica rappresenta la distanza tra il valore stimato e quello misurato, ovvero quanto il primo \`e lontano dal secondo.
Nella letteratura della teoria del controllo, modelli con un'accuratezza superiore al 70\% sono considerati accettabili approssimazioni della dinamica di sistemi reali.

Per ogni momento statistico (media, deviazione standard, \ldots) di una serie storica (ma non solo) si pu\`o definire un \textit{intervallo di confidenza} 
che esprime la probabilit\`a che il valore calcolato sugli $N$ campioni della serie approssimi il valore effettivo del momento statistico.
Questo intevallo, nel caso del valore medio, si definisce come 
\begin{equation}
    Pr\{\bar{x} - \epsilon \leq \mu \leq \bar{x} + \epsilon\} = 1 - \delta,
    \label{eq:2}
\end{equation}
in cui $\mu$ e $\bar{x}$ sono, rispettivamente, la media effettiva e quella calcolata. $\epsilon$ e $\delta$ sono valori che dipendono da $N$, e mantenendo $\delta$ costante
e incrementando $N$, anche $\epsilon$ cresce, allargando l'intervallo di confidenza.
Tale intervallo pu\`o essere definito anche per momenti di ordine superiore.

Nel contesto del presente lavoro, come si vedr\`a, volendo giudicare la legittimit\`a delle misurazioni di un determinato sensore, determinate propriet\`a statistiche delle nuove misurazioni (nuove nel contesto di normale 
funzionamento del sistema \textit{aperto} ad attacchi) verranno confrontate con le stesse propriet\`a di misurazioni effettuate in condizioni \textit{sicure} (questi valori sono chiamati valori di \textit{reference}). 
Per le nuove misurazioni, prendendo ancora in esempio il valore medio e volendo avere un intervallo di confidenza il pi\`u piccolo possibile (quindi un $\epsilon$ il pi\`u piccolo possibile), bisogna essere attenti per via di valori di $N$ non molto grandi,
caratteristica preferibile in quanto non si vogliono campionare troppi valori in situazioni real-time (equivarrebbe ad aspettare di pi\`u per prendere una decisione, e quindi essere potenzialmente per più tempo sotto attacco).
Scegliere un'intervallo di condifenza delle nuove misurazioni troppo grande potrebbe portare ad una sovrapposizione tra il nuovo intervallo ed quello di reference\footnote{Il caso ideale sarebbe o di inclusione del primo nel secondo o di disgiunzione, rilevando nel primo caso un valore ammesso e nel secondo caso un attacco.}.
Per avere una sensibilit\`a migliore contro gli attacchi il problema viene affrontato avvalendosi dell'aiuto di un determintao modello di \textit{Machine Learning}, 
che ha un buon comprtamento verso valori che non sono perfettamente discriminabili.

A tale scopo viene definito un problema di M.L. che ha come \textit{feature} alcuni valori statistici (di cui si \`e parlato precedentemente) estratti dai vettori residui\footnote{Il vettore dei residui \`e quindi parte fondamentale per la definizione dei fingerprint dei sensori.}.
Queste feature sono mostrate nella Tabella \ref{tab:1}.

\begin{table}[tb]
    \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    \textbf{Feature} & \textbf{Descrizione} \\
    \hline
    Media & $\bar{x} = \frac{1}{N}\sum_{i=1}^N x_i$ \\
    \hline
    Varianza & $\sigma = \frac{1}{N}\sum_{i=1}^N (x_i - \bar{x})^2 $ \\
    \hline
    Dev. Med. Ass. & $D_{\bar{x}} = \frac{1}{N}\sum_{i=1}^N |x_i - \bar{x}|$ \\
    \hline
    Asimmetria & $\gamma = \frac{1}{N} \sum_{i=1}^N (\frac{x_i - \bar{x}}{\sigma})^3 $ \\
    \hline
    Curtosi & $ \beta = \frac{1}{N} \sum_{i=1}^N (\frac{x_i - \bar{x}}{\sigma})^4 - 3$\\
    \hline
    \end{tabular}
    \end{center}
    \caption{Lista delle feature utilizzate; $x$ \`e la serie temporale di dimensione $N$ proveniente dal sensore.}
    \label{tab:1}
\end{table}

Un problema di M.L. pu\`o essere definito come una funzione 
\begin{equation}
f: X \to Y,\label{eq:3}
\end{equation}
dato un insieme $D$ (dataset) contenente informazioni riguardanti $f$.
Fare il \textit{learning} della funzione $f$ significa trovare un'altra funzione $\hat{f}$ che approssima e ritorna valori più vicini possibile ad $f$, specialmente per elementi non presenti in $D$.
Nel presente lavoro il problema viene definito come un problema di \textit{classificazione}, ovvero in cui $f$ \`e definita tale che
\begin{equation}
    \begin{array}{l}
    X := \mathbb{R}^m, \\
    Y := \{ C_1, C_2, \ldots, C_k \};
    \end{array}
\end{equation} 
e \textit{supervised}, cio\'e in cui il datasert \`e del tipo
\begin{equation}
    D = \{ (x_i, y_i)_{i=1}^N \}, x_i\in X, y_i\in Y
\end{equation}
Quindi $f$ associa ad ogni elemento di $X$, cio\`e un vettore di $m$ reali, un elemento di $Y$, cio\`e la classe $C_i$ di appartenenza.

% ----------------------------------------------------------------------------------------

\chapter{Metodi}\label{chap:2}

% Describe here the algorithm design from a math perspective. No code here.
% Descrivere la suddivisione in chunks e come viene definito il modello di M.L.
Come anticipato nella precedente sezione, il prossimo passo \`e quello di definire correttamente il problema di M.L. ed utilizzare un algoritmo di learning adeguato.
A questo scopo bisogna preparare i dati estratti dai sensori (e di conseguenza il vettore dei residui) per poter essere utilizzati efficacemente dall'algoritmo di learning.
Il dataset conterr\`a coppie in cui il primo elemento $x_i$ \`e un vettore le feature elencate nella Tabella \ref{tab:1}, e il secondo elemento $y_i$ \`e la classe di apparteneza che rappresenta il sensore che ha prodotto le misurazioni utilizzate per costruire $x_i$.
Data la natura statistica delle feature utilizzate, sarebbe inadeguato estrarre le stesse basandosi solamente sulla misurazione avvenuto all'istante di tempo $k$.
Detto ci\`o, bisogna partizionare ogni serie temporale in blocchetti (\textit{chunk}) di dimensione $d$. 
Da ogni chunk verranno poi estratte le feature precedentemente menzionate ed etichettate con la classe (quindi sensore) di appartenenza.
Scegliere la giusta dimensione $d$ dei vari chunk \`e una scelta sensibile in quanto forzer\`a anche la dimensione dei chunk composti da residui di sensori che verranno calcolati durante il normale funzionamento del sistema.
L'idea \`e di avere chunk di serie temporali abbastanza grandi da catturare la dinamica del processo e piccoli abbastanza da ridurre il tempo di attesa per discriminare nuove misurazioni.

Tutte le istanze di $X$ che appartengono allo stesso sensore determinano il fingerprint del sensore e il primo compito della funzione $f$ (Funzione \ref{eq:3}) \`e quello di distinguere correttamente i sensori, 
quindi generare un fingerprint il pi\`u preciso e privo di ambiguit\`a possibile. Nella sezione 5, l'esistenza del fingerprint verr\`a provata empiricamente.

L'algoritmo di M.L. utilizzato \`e il \textit{Support Vector Machine} (SVM), impiegato come un classificatore a 2 classi (One vs. One) che etichetta i dati provenienti dal legittimo sensore (\textit{ground truth}) come un \textit{1}
e come \textit{0} i dati provenienti dagli altri sensori. In questo modo gli attacchi possono essere considerati come un tipo dato appartenente ad altre classi.

L'algoritmo di SVM verr\`a allenato su un campione di dati che dipender\`a dal sistema considerato e verr\`a validato usando la tecnica del \textit{k-fold cross validation}.
Successivamente, siccome nel dataset non sono presenti dati relativi ad attacchi, il classificatore a 2 classi potrebbe mancare alcuni degli attacchi.

Per affrontare questo problema viene utilizzato la modalit\`a di SVM ad una classe (\textit{one-class} SVM) per fare il learning del modello di M.L., basandosi su una classe di dati normali (appartenenti quindi ad un solo sensore). 
Nella fase di testing tutto ci\`o reputato estraneo viene considerato come un attacco.

% ----------------------------------------------------------------------------------------

\chapter{Implementazione}
% describe here how you implemented the functionalities described in the methods section.
% Use pseudo-code or diagrams.
% Parlare del come si è implementato il rumore intrinseco in un modello symulink
Alla luce di quanto detto nel Capitolo \ref{chap:1} per quanto riguarda l'estrazione del vettore dei residui, nel presente lavoro viene presa una strada diversa, alternativa e pi\`u semplice di quella presentata in [2].

Il rumore process noise viene creato ``artificialmente''. Si utilizza un modello di sistema dinamico ideale, che non introduce alcun tipo di rumore nelle misurazioni di sensori. 
Sia $y_k$ l'output di un sistema del tipo definito in \ref{eq:4} all'istante $k$ e siano $\delta_j$, $j = 1,\ldots,m$\footnote{{$m$ \`e la dimensione di $y_k$, uguale al numero di sensori del sistema.}}, $m$ variabili aleatorie (una per sensore) $\delta_i \tilde{} N(0,\sigma^2)$ con distruzione di probabilit\`a gaussiana,
a media nulla e varianza non zero. Il valore di $y_i$ 

% ----------------------------------------------------------------------------------------

\chapter{Risultati sperimentali}
% describe the experimental results
In questo capitolo vengono delineati gli obiettivi della fase sperimentale, il software utilizzato per simulare i sistemi e che produrr\`a i valori di output 
che sono di interesse per questo lavoro. Vengono presentati di conseguenza due modelli che utilizzati come banco di prova per le tecniche descritte nel Capitolo \ref{chap:2}.

\section{Obiettivi}
% describe here the objectives of the experimental activity: test correctness;
% evaluate computational performances (CPU time and RAM); ....
Gli obiettivi principali di questa fase sono molteplici:
\begin{itemize}
    \item Provare l'esistenza del fingerprint relativo ai sensori e quindi della distinguibilit\`a dei dati provenienti da sensori diversi.
    \item Trovare la giusta dimensione dei chunk in cui saranno divisi i vettori dei residui.
    \item Mostrare che la quantit\`a di dati di sensori acquisita non indice particolarmente sul fingerprint.
    \item Definire la tipologia di attacchi che possono essere identificati e quindi valutare la precisione con cui vengono riconosciuti.
 \end{itemize}

\section{Configurazione}
% describe experimental setting: hardware used, software used, data used, etc. ....
Il programma che implementa le funzionalit\`a qui presentate \`e stato scritto utilizzando diversi linguaggi di programmazione, tra cui principalmente Python e MATLAB.
Il software utilizzato per ottenere dati provenienti da simulazioni di sistemi cyber-fisici \`e Simulink, un software per simulazione e modellazione di sistemi dinamici.

\section{Casi di studio}
% describe here the case studies used in the experiments
% car e climate 

\section{Correttezza}
% describe here experiments aimed at showing correctness of your implementation
% Risultati cross-validation
% esistenza del fingerprint e a corretta discriminazione tra sensori

\section{Valutazione computazionale}
% describe here experiments aimed at evaluating computational performance (e.g., CPU usage, RMA usage, etc)

\section{Valutazione tecnica}
% describe here experiments aimed at evaluating your tools wrt their intended use.
% For example, software to detect adversarial attacks will be evaluated here showing how good (or bad) it is in detecting attcks.
% Parlare della grandezza dei chunks trovati

\chapter{Conclusioni}
% Sum up what you did and outline some possible future developments.

\backmatter
% Inserire qui referenze e citazioni

\end{document}